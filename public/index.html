<!DOCTYPE html><html><head><title>UPort Documentation</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"><link rel="stylesheet" href="css/style.css"></head><body><header class="header"><div class="header-wrap"><div class="header-left"><a class="logo-link" href="#portal"><span>uPort | Developers</span></a></div><div class="header-right"><nav class="nav"><ul class="nav-list"><li class="nav-item"><a class="nav-link" href="#guides"><span>Guides</span></a></li><li class="nav-item"><a class="nav-link" href="#apidocs"><span>API Docs</span></a></li><li class="nav-item"><a class="nav-link" href="#tools"><span>Tools</span></a></li><li class="nav-item"><a class="nav-link" href="#myapps"><span>My Apps</span></a></li><li class="nav-item"><a class="nav-link" href="#gitter"><span>Gitter</span></a></li><li class="nav-item"><a class="nav-link" href="https://github.com/uport-project" target="_blank"><span>Github</span></a></li></ul></nav><div class="user-area"><a class="sign-in-link" href="#"><span>Sign In</span></a><div class="user"><img class="user-pic" src="#"><div class="user-menu"><ul><li class="user"><b class="user-name">Jeff Scott Ward</b><span class="user-addr">0x9239812437981247</span></li><li class="log-out"><a href="#">Log Out</a></li></ul></div></div></div></div></div></header><!-- default to .main.______ page--><main class="main guides"><div class="portal"><div class="banner"><div class="banner-text"><h1>uPort Documentation</h1><p class="text-block">uPort is an open source software project to establish a global, unified, sovereign identity system for people, businesses, organizations, devices, and bots.</p></div><div class="banner-steps"><ul><li class="alpha"><div class="number"><span class="number-text">1</span></div><img class="step-img" src="#"><div class="step-desc">Download the Mobile Wallet</div></li><li class="beta"><div class="number"><span class="number-text">2</span></div><img class="step-img" src="#"><div class="step-desc">Register Your App</div></li><li class="omega"><div class="number"><span class="number-text">3</span></div><img class="step-img" src="#"><div class="step-desc">Install the Libraries / SDK's</div></li></ul></div></div><div class="content-shortcuts"><ul><li class="guides"><div class="shortcut-wrap"><img src="#"><label>Guides</label></div><div class="list-wrap"><ul><li><a href="#"><span>Getting Started</span></a></li><li><a href="#"><span>Requesting Credentials</span></a></li><li><a href="#"><span>Attesting Credentials</span></a></li><li><a href="#"><span>Signing Transactions</span></a></li></ul></div></li><li class="api-docs"><div class="shortcut-wrap"><img src="#"><label>API Docs</label></div><div class="list-wrap"><ul><li><a href="#"><span>uport-connect</span></a></li><li><a href="#"><span>uport-js</span></a></li><li><a href="#"><span>uport-lite</span></a></li><li><a href="#"><span>uport-registry</span></a></li></ul></div></li><li class="tools"><div class="shortcut-wrap"><img src="#"><label>Tools</label></div><div class="list-wrap"><ul><li><a href="http://truffleframework.com"><span>Truffle</span></a></li><li><a href="http://metamask.io"><span>MetaMask</span></a></li><li><a href="https://remix.ethereum.org/#version=soljson-v0.4.13+commit.fb4cb1a.js"><span>Remix</span></a></li><li><a href="https://github.com/ethereum/mist/releases"><span>Mist</span></a></li></ul></div></li></ul></div></div><div class="guides"><div class="pagewrap"><div class="sidebar"></div><div class="content"><div class="guide"><section><h1>Getting Started</h1>
<h2>Download the Mobile App</h2>
<p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.</p>
<h2>Create your Identity</h2>
<pre><code class="language-js">const uport = new Connect('NAME_OF_DAPP', {
  clientId: 'CLIENT_ID',
  signer: SimpleSigner('SIGNING KEY')
})

const web3 = uport.getWeb3()
export { web3, uport }
</code></pre>
<h2>Register your App</h2>
<p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.</p>
<h2>Install the Library/SDK</h2>
<p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.</p>
<h2>Add your Keys</h2>
<p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.</p>
</section><section><h1>Requesting Credentials</h1>
<h2>Calling the Method</h2>
<h2>Requesting specific crednetials</h2>
<h2>Enabling Push Notifications</h2>
<h2>Logging in via Desktop (web)</h2>
<h2>Custom QR Styling</h2>
<h2>Logging in via Mobile (web)</h2>
<h2>Logging in via Mobile (sdk)</h2>
</section><section><h1>Attesting Credentials</h1>
<h2>Calling the Method</h2>
<h2>Attesting a credential</h2>
<h2>Setting an expiration date</h2>
<h2>Attesting multiple credentials</h2>
</section><section><h1>Signing Transactions</h1>
<h2>Supply the contract ABI</h2>
<h2>Create the contract object</h2>
<h2>Call a method on the contract</h2>
<h2>Wait for mining to complete</h2>
</section></div><section class="guide"></section><section class="guide"></section></div></div></div><div class="apidocs"><div class="pagewrap"><div class="sidebar"><section><h2> <a href="#uport-connect">uport-connect</a></h2><ul></ul></section><section><h2> <a href="#uport-js">uport-js</a></h2><ul></ul></section><section><h2> <a href="#uport-registry">uport-registry</a></h2><ul></ul></section></div><div class="content"><section class="lib-section" id="uport-connect"><h1 class="lib-header">uport-connect</h1><div class="lib-doc"><h2>Classes</h2>
<dl>
<dt><a href="#Connect">Connect</a> ⇐ <code><a href="#ConnectCore">ConnectCore</a></code></dt>
<dd><p>Primary object for frontend interactions with uPort. Bundles all neccesary functionality.</p>
</dd>
<dt><a href="#ConnectCore">ConnectCore</a></dt>
<dd><p>Primary object for frontend interactions with uPort. ConnectCore excludes
 some functionality found in Connect for a more customizable and lightweight integration.
 It does not provide any web3 functionality althought you can still use getProvider
 to get a provider to use with web3 or other libraries. It removes all default
 QR injection functionality. Your can choose how you want to handle the UX and/or
 QR generation and use any QR library you choose. For example, if used in a
 mobile native app QR generation is not even necessary.</p>
</dd>
</dl>
<p><a name="Connect"></a></p>
<h2>Connect ⇐ <a href="#ConnectCore"><code>ConnectCore</code></a></h2>
<p>Primary object for frontend interactions with uPort. Bundles all neccesary functionality.</p>
<p><strong>Kind</strong>: global class<br>
<strong>Extends</strong>: <a href="#ConnectCore"><code>ConnectCore</code></a></p>
<ul>
<li><a href="#Connect">Connect</a> ⇐ <a href="#ConnectCore"><code>ConnectCore</code></a>
<ul>
<li><a href="#new_Connect_new">new Connect(appName, [opts])</a></li>
<li><a href="#Connect+getWeb3">.getWeb3()</a> ⇒ <code>web3</code></li>
<li><a href="#ConnectCore+getProvider">.getProvider()</a> ⇒ <code>UportSubprovider</code></li>
<li><a href="#ConnectCore+requestCredentials">.requestCredentials([request], [uriHandler])</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+requestAddress">.requestAddress([uriHandler])</a> ⇒ <code>Promise.&lt;String, Error&gt;</code></li>
<li><a href="#ConnectCore+attestCredentials">.attestCredentials(credential, [uriHandler])</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+request">.request(request)</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+contract">.contract(abi)</a> ⇒ <code>Object</code></li>
<li><a href="#ConnectCore+sendTransaction">.sendTransaction(txobj)</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+addAppParameters">.addAppParameters(txobj, callbackUrl)</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
</ul>
</li>
</ul>
<hr>
<p><a name="new_Connect_new"></a></p>
<h3>new Connect(appName, [opts])</h3>
<p>Instantiates a new uPort connect object.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>appName</td><td><code>String</code></td><td></td><td><p>the name of your app</p>
</td>
    </tr><tr>
    <td>[opts]</td><td><code>Object</code></td><td></td><td><p>optional parameters</p>
</td>
    </tr><tr>
    <td>opts.credentials</td><td><code>Object</code></td><td></td><td><p>pre-configured Credentials object from <a href="http://github.com/uport-project/uport-js">http://github.com/uport-project/uport-js</a> object. Configure this if you need to create signed requests</p>
</td>
    </tr><tr>
    <td>opts.signer</td><td><code>function</code></td><td></td><td><p>signing function which will be used to sign JWT&#39;s in the credentials object</p>
</td>
    </tr><tr>
    <td>opts.clientId</td><td><code>String</code></td><td></td><td><p>uport identifier for your application this will be used in the default credentials object</p>
</td>
    </tr><tr>
    <td>[opts.network]</td><td><code>Object</code></td><td><code>&#x27;kovan&#x27;</code></td><td><p>network config object or string name, ie. { id: &#39;0x1&#39;, registry: &#39;0xab5c8051b9a1df1aab0149f8b0630848b7ecabf6&#39;, rpcUrl: &#39;<a href="https://mainnet.infura.io">https://mainnet.infura.io</a>&#39; } or &#39;kovan&#39;, &#39;mainnet&#39;, &#39;ropsten&#39;.</p>
</td>
    </tr><tr>
    <td>opts.rpcUrl</td><td><code>String</code></td><td></td><td><p>JSON rpc url (defaults to <a href="https://ropsten.infura.io">https://ropsten.infura.io</a>)</p>
</td>
    </tr><tr>
    <td>opts.infuraApiKey</td><td><code>String</code></td><td></td><td><p>Infura API Key (register here <a href="http://infura.io/register.html">http://infura.io/register.html</a>)</p>
</td>
    </tr><tr>
    <td>opts.topicFactory</td><td><code>function</code></td><td></td><td><p>function which generates topics and deals with requests and response</p>
</td>
    </tr><tr>
    <td>opts.uriHandler</td><td><code>function</code></td><td></td><td><p>default function to consume generated URIs for requests, can be used to display QR codes or other custom UX</p>
</td>
    </tr><tr>
    <td>opts.mobileUriHandler</td><td><code>function</code></td><td></td><td><p>default function to consume generated URIs for requests on mobile</p>
</td>
    </tr><tr>
    <td>opts.closeUriHandler</td><td><code>function</code></td><td></td><td><p>default function called after a request receives a response, can be to close QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">import { Connect } from 'uport-connect'
const uPort = new Connect('Mydapp')
</code></pre>
<hr>
<p><a name="Connect+getWeb3"></a></p>
<h3>connect.getWeb3() ⇒ <code>web3</code></h3>
<p>Instantiates and returns a web3 object wrapped with uPort functionality. For
more details see uportSubprovider and getProvider in connectCore.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>web3</code> - A uPort web3 object</p>
<hr>
<p><a name="ConnectCore+getProvider"></a></p>
<h3>connect.getProvider() ⇒ <code>UportSubprovider</code></h3>
<p>Instantiates and returns a web3 styple provider wrapped with uPort functionality.
For more details see uportSubprovider. uPort overrides eth_coinbase and eth_accounts
to start a get address flow or to return an already received address. It also
overrides eth_sendTransaction to start the send transaction flow to pass the
transaction to the uPort app.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>UportSubprovider</code> - A web3 style provider wrapped with uPort functionality</p>
<hr>
<p><a name="ConnectCore+requestCredentials"></a></p>
<h3>connect.requestCredentials([request], [uriHandler]) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Creates a request given a request object, will also always return the user's
uPort address. Calls given uriHandler with the uri. Returns a promise to
wait for the response.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - a promise which resolves with a response object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>[request]</td><td><code>Object</code></td><td><code>{}</code></td><td><p>request object</p>
</td>
    </tr><tr>
    <td>[uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const req = {requested: ['name', 'country']}
 connect.requestCredentials(req).then(credentials =&gt; {
     const address = credentials.address
     const name = credentials.name
     ...
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+requestAddress"></a></p>
<h3>connect.requestAddress([uriHandler]) ⇒ <code>Promise.&lt;String, Error&gt;</code></h3>
<p>Creates a request for only the address of the uPort identity. Calls given
uriHandler with the uri. Returns a promise to wait for the response.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;String, Error&gt;</code> - a promise which resolves with an address or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>[uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+attestCredentials"></a></p>
<h3>connect.attestCredentials(credential, [uriHandler]) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Consumes a credential object and generates a signed JWT. Creates a request
URI with the JWT. Calls given uriHandler with the URI. Returns a promise to wait
for the response. Throws error if no signer and/or app identifier is set.
Will not always receive a response, response is only a status.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - a promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>credential</td><td><code>Object</code></td><td></td><td><p>credential object</p>
</td>
    </tr><tr>
    <td>credential.sub</td><td><code>String</code></td><td></td><td><p>subject of this credential</p>
</td>
    </tr><tr>
    <td>credential.claim</td><td><code>Object</code></td><td></td><td><p>statement(s) which this credential claims, contructed as {key: &#39;value&#39;, ...}</p>
</td>
    </tr><tr>
    <td>credential.exp</td><td><code>String</code></td><td></td><td><p>expiry time of this credential</p>
</td>
    </tr><tr>
    <td>[uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const cred = {
   sub: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347'
   claim: {'email': 'hello@uport.me'}
   exp: '1300819380'
 }
 connect.attestCredentials(cred).then(res =&gt; {
   // response okay, received in uPort app
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+request"></a></p>
<h3>connect.request(request) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Create a request and returns a promise which resolves the response. This
function is primarly is used by more specified functions in this class, which
allow you to easily create the URIs and messaging server topics you need here.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - promise which resolves with a response object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>request</td><td><code>Object</code></td><td></td><td><p>request object</p>
</td>
    </tr><tr>
    <td>request.uri</td><td><code>String</code></td><td></td><td><p>uPort URI</p>
</td>
    </tr><tr>
    <td>request.topic</td><td><code>String</code></td><td></td><td><p>messaging server topic object</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td><code>String</code></td><td><code>this.uriHandler</code></td><td><p>function to consume URI, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+contract"></a></p>
<h3>connect.contract(abi) ⇒ <code>Object</code></h3>
<p>Builds and returns a contract object which can be used to interact with
a given contract. Similar to web3.eth.contract but with promises. Once specifying .at(address)
you can call the contract functions with this object. It will create a request,
call the uirHandler with the URI, and return a promise which resolves with
a transtaction ID.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Object</code> - contract object</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>abi</td><td><code>Object</code></td><td></td><td><p>contract ABI</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+sendTransaction"></a></p>
<h3>connect.sendTransaction(txobj) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Given a transaction object, similarly defined as the web3 transaction object,
it creates a URI which is passes to the uirHandler. It will create request
and returns a promise which resolves with the transaction id.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - A promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>txobj</td><td><code>Object</code></td><td></td><td><p>transaction object, can also be wrapped using addAppParameters</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const txobject = {
   to: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347',
   value: '0.1',
   function: setStatus(string 'hello', bytes32 '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347'),
   appName: 'MyDapp'
 }
 connect.sendTransaction(txobject).then(txID =&gt; {
   ...
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+addAppParameters"></a></p>
<h3>connect.addAppParameters(txobj, callbackUrl) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Adds application specific data to a transaction object. Then uses this data
when requests are created.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - A promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>txobj</td><td><code>Object</code></td><td><p>transaction object</p>
</td>
    </tr><tr>
    <td>callbackUrl</td><td><code>String</code></td><td><p>application callback url</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore"></a></p>
<h2>ConnectCore</h2>
<p>Primary object for frontend interactions with uPort. ConnectCore excludes
some functionality found in Connect for a more customizable and lightweight integration.
It does not provide any web3 functionality althought you can still use getProvider
to get a provider to use with web3 or other libraries. It removes all default
QR injection functionality. Your can choose how you want to handle the UX and/or
QR generation and use any QR library you choose. For example, if used in a
mobile native app QR generation is not even necessary.</p>
<p><strong>Kind</strong>: global class</p>
<ul>
<li><a href="#ConnectCore">ConnectCore</a>
<ul>
<li><a href="#new_ConnectCore_new">new ConnectCore(appName, [opts])</a></li>
<li><a href="#ConnectCore+getProvider">.getProvider()</a> ⇒ <code>UportSubprovider</code></li>
<li><a href="#ConnectCore+requestCredentials">.requestCredentials([request], [uriHandler])</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+requestAddress">.requestAddress([uriHandler])</a> ⇒ <code>Promise.&lt;String, Error&gt;</code></li>
<li><a href="#ConnectCore+attestCredentials">.attestCredentials(credential, [uriHandler])</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+request">.request(request)</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+contract">.contract(abi)</a> ⇒ <code>Object</code></li>
<li><a href="#ConnectCore+sendTransaction">.sendTransaction(txobj)</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+addAppParameters">.addAppParameters(txobj, callbackUrl)</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
</ul>
</li>
</ul>
<hr>
<p><a name="new_ConnectCore_new"></a></p>
<h3>new ConnectCore(appName, [opts])</h3>
<p>Instantiates a new uPort connectCore object.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>appName</td><td><code>String</code></td><td></td><td><p>the name of your app</p>
</td>
    </tr><tr>
    <td>[opts]</td><td><code>Object</code></td><td></td><td><p>optional parameters</p>
</td>
    </tr><tr>
    <td>opts.credentials</td><td><code>Object</code></td><td></td><td><p>pre-configured Credentials object from <a href="http://github.com/uport-project/uport-js">http://github.com/uport-project/uport-js</a> object. Configure this if you need to create signed requests</p>
</td>
    </tr><tr>
    <td>opts.signer</td><td><code>function</code></td><td></td><td><p>signing function which will be used to sign JWT&#39;s in the credentials object</p>
</td>
    </tr><tr>
    <td>opts.clientId</td><td><code>String</code></td><td></td><td><p>uport identifier for your application this will be used in the default credentials object</p>
</td>
    </tr><tr>
    <td>[opts.network]</td><td><code>Object</code></td><td><code>&#x27;kovan&#x27;</code></td><td><p>network config object or string name, ie. { id: &#39;0x1&#39;, registry: &#39;0xab5c8051b9a1df1aab0149f8b0630848b7ecabf6&#39;, rpcUrl: &#39;<a href="https://mainnet.infura.io">https://mainnet.infura.io</a>&#39; } or &#39;kovan&#39;, &#39;mainnet&#39;, &#39;ropsten&#39;.</p>
</td>
    </tr><tr>
    <td>opts.infuraApiKey</td><td><code>String</code></td><td></td><td><p>Infura API Key (register here <a href="http://infura.io/register.html">http://infura.io/register.html</a>)</p>
</td>
    </tr><tr>
    <td>opts.topicFactory</td><td><code>function</code></td><td></td><td><p>function which generates topics and deals with requests and response</p>
</td>
    </tr><tr>
    <td>opts.uriHandler</td><td><code>function</code></td><td></td><td><p>default function to consume generated URIs for requests, can be used to display QR codes or other custom UX</p>
</td>
    </tr><tr>
    <td>opts.mobileUriHandler</td><td><code>function</code></td><td></td><td><p>default function to consume generated URIs for requests on mobile</p>
</td>
    </tr><tr>
    <td>opts.closeUriHandler</td><td><code>function</code></td><td></td><td><p>default function called after a request receives a response, can be to close QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">import { ConnectCore } from 'uport-connect'
const uPort = new ConnectCore('Mydapp')
</code></pre>
<hr>
<p><a name="ConnectCore+getProvider"></a></p>
<h3>connectCore.getProvider() ⇒ <code>UportSubprovider</code></h3>
<p>Instantiates and returns a web3 styple provider wrapped with uPort functionality.
For more details see uportSubprovider. uPort overrides eth_coinbase and eth_accounts
to start a get address flow or to return an already received address. It also
overrides eth_sendTransaction to start the send transaction flow to pass the
transaction to the uPort app.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>UportSubprovider</code> - A web3 style provider wrapped with uPort functionality</p>
<hr>
<p><a name="ConnectCore+requestCredentials"></a></p>
<h3>connectCore.requestCredentials([request], [uriHandler]) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Creates a request given a request object, will also always return the user's
uPort address. Calls given uriHandler with the uri. Returns a promise to
wait for the response.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - a promise which resolves with a response object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>[request]</td><td><code>Object</code></td><td><code>{}</code></td><td><p>request object</p>
</td>
    </tr><tr>
    <td>[uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const req = {requested: ['name', 'country']}
 connect.requestCredentials(req).then(credentials =&gt; {
     const address = credentials.address
     const name = credentials.name
     ...
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+requestAddress"></a></p>
<h3>connectCore.requestAddress([uriHandler]) ⇒ <code>Promise.&lt;String, Error&gt;</code></h3>
<p>Creates a request for only the address of the uPort identity. Calls given
uriHandler with the uri. Returns a promise to wait for the response.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;String, Error&gt;</code> - a promise which resolves with an address or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>[uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+attestCredentials"></a></p>
<h3>connectCore.attestCredentials(credential, [uriHandler]) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Consumes a credential object and generates a signed JWT. Creates a request
URI with the JWT. Calls given uriHandler with the URI. Returns a promise to wait
for the response. Throws error if no signer and/or app identifier is set.
Will not always receive a response, response is only a status.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - a promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>credential</td><td><code>Object</code></td><td></td><td><p>credential object</p>
</td>
    </tr><tr>
    <td>credential.sub</td><td><code>String</code></td><td></td><td><p>subject of this credential</p>
</td>
    </tr><tr>
    <td>credential.claim</td><td><code>Object</code></td><td></td><td><p>statement(s) which this credential claims, contructed as {key: &#39;value&#39;, ...}</p>
</td>
    </tr><tr>
    <td>credential.exp</td><td><code>String</code></td><td></td><td><p>expiry time of this credential</p>
</td>
    </tr><tr>
    <td>[uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const cred = {
   sub: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347'
   claim: {'email': 'hello@uport.me'}
   exp: '1300819380'
 }
 connect.attestCredentials(cred).then(res =&gt; {
   // response okay, received in uPort app
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+request"></a></p>
<h3>connectCore.request(request) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Create a request and returns a promise which resolves the response. This
function is primarly is used by more specified functions in this class, which
allow you to easily create the URIs and messaging server topics you need here.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - promise which resolves with a response object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>request</td><td><code>Object</code></td><td></td><td><p>request object</p>
</td>
    </tr><tr>
    <td>request.uri</td><td><code>String</code></td><td></td><td><p>uPort URI</p>
</td>
    </tr><tr>
    <td>request.topic</td><td><code>String</code></td><td></td><td><p>messaging server topic object</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td><code>String</code></td><td><code>this.uriHandler</code></td><td><p>function to consume URI, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+contract"></a></p>
<h3>connectCore.contract(abi) ⇒ <code>Object</code></h3>
<p>Builds and returns a contract object which can be used to interact with
a given contract. Similar to web3.eth.contract but with promises. Once specifying .at(address)
you can call the contract functions with this object. It will create a request,
call the uirHandler with the URI, and return a promise which resolves with
a transtaction ID.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Object</code> - contract object</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>abi</td><td><code>Object</code></td><td></td><td><p>contract ABI</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+sendTransaction"></a></p>
<h3>connectCore.sendTransaction(txobj) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Given a transaction object, similarly defined as the web3 transaction object,
it creates a URI which is passes to the uirHandler. It will create request
and returns a promise which resolves with the transaction id.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - A promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>txobj</td><td><code>Object</code></td><td></td><td><p>transaction object, can also be wrapped using addAppParameters</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const txobject = {
   to: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347',
   value: '0.1',
   function: setStatus(string 'hello', bytes32 '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347'),
   appName: 'MyDapp'
 }
 connect.sendTransaction(txobject).then(txID =&gt; {
   ...
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+addAppParameters"></a></p>
<h3>connectCore.addAppParameters(txobj, callbackUrl) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Adds application specific data to a transaction object. Then uses this data
when requests are created.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - A promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>txobj</td><td><code>Object</code></td><td><p>transaction object</p>
</td>
    </tr><tr>
    <td>callbackUrl</td><td><code>String</code></td><td><p>application callback url</p>
</td>
    </tr>  </tbody>
</table>
<hr>
</div></section><section class="lib-section" id="uport-js"><h1 class="lib-header">uport-js</h1><div class="lib-doc"></div></section><section class="lib-section" id="uport-registry"><h1 class="lib-header">uport-registry</h1><div class="lib-doc"></div></section></div></div></div><div class="tools"><div class="pagewrap"><div class="sidebar"></div><div class="content"><ul><li><a href="http://truffleframework.com" target="_blank"><img src="/img/truffle-logo.svg"><h3 class="title">Truffle</h3><p class="desc">Truffle is the most popular development framework for Ethereum with a mission to make your life a whole lot easier.</p></a></li><li><a href="http://metamask.io" target="_blank"><img src="/img/metamask-logo.png"><h3 class="title">Metamask</h3><p class="desc">MetaMask is a bridge that allows you to visit the distributed web of tomorrow in your browser today. It allows you to run Ethereum dApps right in your browser without running a full Ethereum node.</p></a></li><li><a href="https://remix.ethereum.org/#version=soljson-v0.4.13+commit.fb4cb1a.js" target="_blank"><img src="/img/ethereum-logo.png"><h3 class="title">Remix</h3><p class="desc">Remix is an IDE for the smart contract programming language Solidity and has an integrated debugger and testing environment.</p></a></li><li><a href="https://github.com/ethereum/mist/releases" target="_blank"><img src="/img/mist-logo.png"><h3 class="title">Mist</h3><p class="desc">The Mist browser is a gateway to decentralized applications on the Ethereum blockchain. It allows you to hold and secure ether and other crypto-assets built on Ethereum, as well as write, deploy and use smart contracts.</p></a></li></ul></div></div></div><div class="myapps"><div class="pagewrap"><div class="sidebar"><section><h2>My Apps</h2><ul><li><a href="#"><span>Application 1</span></a></li><li><a href="#"><span>Application 2</span></a></li><li><a href="#"><span>Application 3</span></a></li><li><a href="#"><span>Application 4</span></a></li><li><a href="#"><span>Application 5</span></a></li></ul></section></div></div></div><div class="gitter"><div class="pagewrap"><div class="sidebar"></div><div class="content"></div></div></div></main><footer class="footer"><div class="footer-wrap"><div class="footer-left"><a class="logo-link" href="#"><div class="logo-group"><img class="logo-img" src="#"><span>| Uport.me</span></div></a></div><div class="footer-right"><nav class="nav"><ul class="nav-list"><li class="nav-item"><a class="nav-link" href="https://github.com/uport-project" target="_blank"><span>D.I.F.</span></a></li><li class="nav-item"><a class="nav-link" href="#" target="_blank"><span>Github</span></a></li></ul></nav><div class="legal-area"><a class="tos" href="#"><span>Terms of Service</span></a><a class="privacy" href="#"><span>Privacy Policy</span></a></div></div></div></footer><script>  ((window.gitter = {}).chat = {}).options = {
    room: 'uport-project/Lobby',
    activationElement: false,
    showChatByDefault: true,
    useStyles: false,
    preload: true,
    targetElement: '.gitter .content'
  };

/* **********************************************
     Begin prism-core.js
********************************************** */

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function(){

// Private helper vars
var lang = /\blang(?:uage)?-(\w+)\b/i;
var uniqueId = 0;

var _ = _self.Prism = {
	util: {
		encode: function (tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
			} else if (_.util.type(tokens) === 'Array') {
				return tokens.map(_.util.encode);
			} else {
				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
			}
		},

		type: function (o) {
			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
		},

		objId: function (obj) {
			if (!obj['__id']) {
				Object.defineProperty(obj, '__id', { value: ++uniqueId });
			}
			return obj['__id'];
		},

		// Deep clone a language definition (e.g. to extend it)
		clone: function (o) {
			var type = _.util.type(o);

			switch (type) {
				case 'Object':
					var clone = {};

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = _.util.clone(o[key]);
						}
					}

					return clone;

				case 'Array':
					// Check for existence for IE8
					return o.map && o.map(function(v) { return _.util.clone(v); });
			}

			return o;
		}
	},

	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		/**
		 * Insert a token before another token in a language literal
		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
		 * we cannot just provide an object, we need anobject and a key.
		 * @param inside The key (or language id) of the parent
		 * @param before The key to insert before. If not provided, the function appends instead.
		 * @param insert Object with the key/value pairs to insert
		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
		 */
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];

			if (arguments.length == 2) {
				insert = arguments[1];

				for (var newToken in insert) {
					if (insert.hasOwnProperty(newToken)) {
						grammar[newToken] = insert[newToken];
					}
				}

				return grammar;
			}

			var ret = {};

			for (var token in grammar) {

				if (grammar.hasOwnProperty(token)) {

					if (token == before) {

						for (var newToken in insert) {

							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					ret[token] = grammar[token];
				}
			}

			// Update references in other language definitions
			_.languages.DFS(_.languages, function(key, value) {
				if (value === root[inside] && key != inside) {
					this[key] = ret;
				}
			});

			return root[inside] = ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function(o, callback, type, visited) {
			visited = visited || {};
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, null, visited);
					}
					else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, i, visited);
					}
				}
			}
		}
	},
	plugins: {},

	highlightAll: function(async, callback) {
		var env = {
			callback: callback,
			selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
		};

		_.hooks.run("before-highlightall", env);

		var elements = env.elements || document.querySelectorAll(env.selector);

		for (var i=0, element; element = elements[i++];) {
			_.highlightElement(element, async === true, env.callback);
		}
	},

	highlightElement: function(element, async, callback) {
		// Find language
		var language, grammar, parent = element;

		while (parent && !lang.test(parent.className)) {
			parent = parent.parentNode;
		}

		if (parent) {
			language = (parent.className.match(lang) || [,''])[1].toLowerCase();
			grammar = _.languages[language];
		}

		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

		// Set language on the parent, for styling
		parent = element.parentNode;

		if (/pre/i.test(parent.nodeName)) {
			parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		}

		var code = element.textContent;

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		_.hooks.run('before-sanity-check', env);

		if (!env.code || !env.grammar) {
			if (env.code) {
				env.element.textContent = env.code;
			}
			_.hooks.run('complete', env);
			return;
		}

		_.hooks.run('before-highlight', env);

		if (async && _self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				env.highlightedCode = evt.data;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				callback && callback.call(env.element);
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code,
				immediateClose: true
			}));
		}
		else {
			env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;

			callback && callback.call(element);

			_.hooks.run('after-highlight', env);
			_.hooks.run('complete', env);
		}
	},

	highlight: function (text, grammar, language) {
		var tokens = _.tokenize(text, grammar);
		return Token.stringify(_.util.encode(tokens), language);
	},

	tokenize: function(text, grammar, language) {
		var Token = _.Token;

		var strarr = [text];

		var rest = grammar.rest;

		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		tokenloop: for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				var pattern = patterns[j],
					inside = pattern.inside,
					lookbehind = !!pattern.lookbehind,
					greedy = !!pattern.greedy,
					lookbehindLength = 0,
					alias = pattern.alias;

				if (greedy && !pattern.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
					pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
				}

				pattern = pattern.pattern || pattern;

				// Don’t cache length as it changes during the loop
				for (var i=0, pos = 0; i<strarr.length; pos += strarr[i].length, ++i) {

					var str = strarr[i];

					if (strarr.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						break tokenloop;
					}

					if (str instanceof Token) {
						continue;
					}

					pattern.lastIndex = 0;

					var match = pattern.exec(str),
					    delNum = 1;

					// Greedy patterns can override/remove up to two previously matched tokens
					if (!match && greedy && i != strarr.length - 1) {
						pattern.lastIndex = pos;
						match = pattern.exec(text);
						if (!match) {
							break;
						}

						var from = match.index + (lookbehind ? match[1].length : 0),
						    to = match.index + match[0].length,
						    k = i,
						    p = pos;

						for (var len = strarr.length; k < len && p < to; ++k) {
							p += strarr[k].length;
							// Move the index i to the element in strarr that is closest to from
							if (from >= p) {
								++i;
								pos = p;
							}
						}

						/*
						 * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
						 * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
						 */
						if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
							continue;
						}

						// Number of tokens to delete and replace with the new match
						delNum = k - i;
						str = text.slice(pos, p);
						match.index -= pos;
					}

					if (!match) {
						continue;
					}

					if(lookbehind) {
						lookbehindLength = match[1].length;
					}

					var from = match.index + lookbehindLength,
					    match = match[0].slice(lookbehindLength),
					    to = from + match.length,
					    before = str.slice(0, from),
					    after = str.slice(to);

					var args = [i, delNum];

					if (before) {
						args.push(before);
					}

					var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

					args.push(wrapped);

					if (after) {
						args.push(after);
					}

					Array.prototype.splice.apply(strarr, args);
				}
			}
		}

		return strarr;
	},

	hooks: {
		all: {},

		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	}
};

var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
	this.type = type;
	this.content = content;
	this.alias = alias;
	// Copy of the full string this token was created from
	this.length = (matchedStr || "").length|0;
	this.greedy = !!greedy;
};

Token.stringify = function(o, language, parent) {
	if (typeof o == 'string') {
		return o;
	}

	if (_.util.type(o) === 'Array') {
		return o.map(function(element) {
			return Token.stringify(element, language, o);
		}).join('');
	}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language, parent),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language,
		parent: parent
	};

	if (env.type == 'comment') {
		env.attributes['spellcheck'] = 'true';
	}

	if (o.alias) {
		var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
		Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run('wrap', env);

	var attributes = Object.keys(env.attributes).map(function(name) {
		return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
	}).join(' ');

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';

};

if (!_self.document) {
	if (!_self.addEventListener) {
		// in Node.js
		return _self.Prism;
	}
 	// In worker
	_self.addEventListener('message', function(evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code,
		    immediateClose = message.immediateClose;

		_self.postMessage(_.highlight(code, _.languages[lang], lang));
		if (immediateClose) {
			_self.close();
		}
	}, false);

	return _self.Prism;
}

//Get current script and highlight
var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

if (script) {
	_.filename = script.src;

	if (document.addEventListener && !script.hasAttribute('data-manual')) {
		if(document.readyState !== "loading") {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(_.highlightAll);
			} else {
				window.setTimeout(_.highlightAll, 16);
			}
		}
		else {
			document.addEventListener('DOMContentLoaded', _.highlightAll);
		}
	}
}

return _self.Prism;

})();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
	global.Prism = Prism;
}


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': /<!--[\w\W]*?-->/,
	'prolog': /<\?[\w\W]+?\?>/,
	'doctype': /<!DOCTYPE[\w\W]+?>/i,
	'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/i,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
				inside: {
					'punctuation': /[=>"']/
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': /&#?[\da-z]{1,8};/i
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function(env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;


/* **********************************************
     Begin prism-css.js
********************************************** */

Prism.languages.css = {
	'comment': /\/\*[\w\W]*?\*\//,
	'atrule': {
		pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
		inside: {
			'rule': /@[\w-]+/
			// See rest below
		}
	},
	'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
	'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
	'string': {
		pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'property': /(\b|\B)[\w-]+(?=\s*:)/i,
	'important': /\B!important\b/i,
	'function': /[-a-z0-9]+(?=\()/i,
	'punctuation': /[(){};:]/
};

Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'style': {
			pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
			lookbehind: true,
			inside: Prism.languages.css,
			alias: 'language-css'
		}
	});
	
	Prism.languages.insertBefore('inside', 'attr-value', {
		'style-attr': {
			pattern: /\s*style=("|').*?\1/i,
			inside: {
				'attr-name': {
					pattern: /^\s*style/i,
					inside: Prism.languages.markup.tag.inside
				},
				'punctuation': /^\s*=\s*['"]|['"]\s*$/,
				'attr-value': {
					pattern: /.+/i,
					inside: Prism.languages.css
				}
			},
			alias: 'language-css'
		}
	}, Prism.languages.markup.tag);
}

/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
			lookbehind: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true
		}
	],
	'string': {
		pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /(\.|\\)/
		}
	},
	'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(true|false)\b/,
	'function': /[a-z0-9_]+(?=\()/i,
	'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
	'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
});

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
		lookbehind: true,
		greedy: true
	}
});

Prism.languages.insertBefore('javascript', 'string', {
	'template-string': {
		pattern: /`(?:\\\\|\\?[^\\])*?`/,
		greedy: true,
		inside: {
			'interpolation': {
				pattern: /\$\{[^}]+\}/,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'script': {
			pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript,
			alias: 'language-javascript'
		}
	});
}

Prism.languages.js = Prism.languages.javascript;

/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
	if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
		return;
	}

	self.Prism.fileHighlight = function() {

		var Extensions = {
			'js': 'javascript',
			'py': 'python',
			'rb': 'ruby',
			'ps1': 'powershell',
			'psm1': 'powershell',
			'sh': 'bash',
			'bat': 'batch',
			'h': 'c',
			'tex': 'latex'
		};

		if(Array.prototype.forEach) { // Check to prevent error in IE8
			Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
				var src = pre.getAttribute('data-src');

				var language, parent = pre;
				var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
				while (parent && !lang.test(parent.className)) {
					parent = parent.parentNode;
				}

				if (parent) {
					language = (pre.className.match(lang) || [, ''])[1];
				}

				if (!language) {
					var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
					language = Extensions[extension] || extension;
				}

				var code = document.createElement('code');
				code.className = 'language-' + language;

				pre.textContent = '';

				code.textContent = 'Loading…';

				pre.appendChild(code);

				var xhr = new XMLHttpRequest();

				xhr.open('GET', src, true);

				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {

						if (xhr.status < 400 && xhr.responseText) {
							code.textContent = xhr.responseText;

							Prism.highlightElement(code);
						}
						else if (xhr.status >= 400) {
							code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
						}
						else {
							code.textContent = '✖ Error: File does not exist or is empty';
						}
					}
				};

				xhr.send(null);
			});
		}

	};

	document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);

})();
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script type="text/javascript" src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script><script type="text/javascript" src="js/script.js"></script></body></html>